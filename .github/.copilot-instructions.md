# Agentic AI Stock Analyzer - Copilot Instructions

## Project Overview
This is an **agentic AI stock analyzer** built using the new **Microsoft Agent Framework** that progresses through multiple milestones, from a simple local stock price agent to a sophisticated multi-agent system deployed on Azure AI Foundry with RAG capabilities.

## Development Context & Architecture

### 🎯 Current Focus
Always check `IMPLEMENTATION_PLAN.md` for the current milestone progress. Look for ⏹️ (not started) vs ✅ (completed) to understand what needs to be built next.

### 🏗️ Target Architecture (Final State)
- **Multi-agent system** on Azure AI Foundry
- **Stock Agent**: Fetches stock prices via APIs (yfinance, Twelve Data)
- **Currency Agent**: Converts USD to SEK
- **Report Agent**: Generates summaries and reports
- **RAG System**: Uses personal watchlist as grounding data
- **Cross-agent orchestration** with proper handoffs

## Development Guidelines

### 🏷️ Naming Convention Standards
**All Azure resources must follow the naming convention: `<env>-<applicationName>-<abbreviation>`**

#### Examples:
- Resource Groups: `test-stockanalyzer-rg`, `prod-stockanalyzer-rg`
- Function Apps: `test-stockanalyzer-func`, `prod-stockanalyzer-func`
- Key Vaults: `test-stockanalyzer-kv`, `prod-stockanalyzer-kv`
- Application Insights: `test-stockanalyzer-ai`, `prod-stockanalyzer-ai`
- Log Analytics: `test-stockanalyzer-la`, `prod-stockanalyzer-la`
- Managed Identity: `test-stockanalyzer-id`, `prod-stockanalyzer-id`

#### Environment Abbreviations:
- `test` - Test environment
- `prod` - Production environment
- `stage` - Staging environment (if used)

#### Common Azure Service Abbreviations:
- `rg` - Resource Group
- `func` - Function App
- `kv` - Key Vault
- `ai` - Application Insights
- `la` - Log Analytics
- `id` - Managed Identity
- `aif` - Azure AI Foundry
- `st` - Storage Account

### 🛠️ Development Workflow & Git Strategy

#### Branch Management
- **NEVER commit or push directly to `main` or `master`**
- Create feature branches using format: `feature/feature-name`
- Examples: `feature/stock-agent`, `feature/currency-conversion`, `feature/rag-integration`
- Work on one feature per branch for clean history

#### Commit Strategy
- **Multiple commits per milestone** - break work into logical chunks
- Use descriptive commit messages following conventional commits:
  ```
  feat: add stock price fetching functionality
  test: add unit tests for ticker extraction
  fix: handle API timeout errors gracefully
  docs: update README with setup instructions
  ```

#### Test-Driven Development (TDD)
- **Write tests FIRST** before implementing features
- Follow TDD cycle: Red → Green → Refactor
- **All tests MUST pass before any commit**
- Use pytest for all unit testing
- Ensure >80% code coverage

#### Milestone Completion Process
1. **Code Implementation** with TDD approach
2. **All tests passing** (run `pytest tests/` successfully)
3. **README.md updated** to reflect current milestone status, features, and project structure
4. **Quality gates passed** (pytest, coverage, linting, type checking)
5. **Mark milestone step as ✅ in `IMPLEMENTATION_PLAN.md`** (while still on feature branch)
6. **Files committed and pushed** to feature branch (including updated implementation plan)
7. **Pull request created** and reviewed
8. **Feature branch merged** to main

#### Quality Gates
```bash
# Before any commit - ALL must pass:
pytest tests/             # All tests must pass (unit + integration)
pytest --cov=src tests/  # Check coverage (>80%)
flake8 src/              # Code style check
mypy src/                # Type checking
```


#### CI/CD Pipeline & Deployment Strategy
- **GitHub Actions** for all CI/CD automation (never deploy directly to Azure)
- **Infrastructure as Code (IaC)** using Bicep templates in `infra/` directory
- **Environment-based deployments**: test → prod (no develop branch, no staging)
- **Security-first approach**: managed identities, Key Vault, least privilege access

#### CI/CD Workflow Requirements
```yaml
# .github/workflows/ci-cd.yml structure:
# 1. Code Quality Gates (on all PRs):
#    - pytest (unit + integration tests)
#    - code coverage >80%
#    - flake8 linting
#    - mypy type checking
#    - security scanning
# 2. Infrastructure Validation:
#    - Bicep template validation
#    - infrastructure preview (what-if deployment)
# 3. Deployment Pipeline:
#    - deploy to test environment (automatic on push)
#    - run smoke tests
#    - deploy to production (only for main branch, approval required)
```

#### Infrastructure as Code (IaC) Guidelines
- **Bicep templates** in `infra/` directory for all Azure resources
- **Security by default**: managed identities, private endpoints, Key Vault
- **Monitoring included**: Application Insights, Log Analytics, alerts
- **Cost optimization**: appropriate SKUs, auto-scaling, resource tagging

#### Deployment Security Standards
```yaml
# Required security configurations:
security:
  authentication:
    - managed_identity: user-assigned (preferred)
    - service_principal: CI/CD only
    - api_keys: stored in Key Vault only
  networking:
    - private_endpoints: production environments
    - network_security_groups: restrictive rules
    - azure_firewall: production workloads
  secrets_management:
    - key_vault: all secrets and certificates
    - rotation_policy: automatic where possible
    - access_policies: least privilege principle
  monitoring:
    - application_insights: performance and errors
    - log_analytics: centralized logging
    - security_center: threat detection
```

#### README Update Requirements
At the end of each milestone, ensure README.md includes:
- **Current milestone status** and completed features
- **Updated project structure** reflecting new files/folders
- **Correct testing commands** for the current test organization
- **Accurate configuration examples** matching current setup
- **Updated usage instructions** if CLI or functionality changed

### �📦 Technology Stack
- **Microsoft Agent Framework** for agent development and orchestration
- **Python** for agent logic and API integration
- **Azure AI Foundry** for agent deployment and orchestration
- **Azure AI Search** for RAG/vector embeddings
- **yfinance** or **Twelve Data API** for stock data
- **Exchange rate APIs** for currency conversion
- **JSON/Markdown** for data storage and reporting

### � Project File Structure
```
agentic-ai-stock-analyzer/
├── .github/
│   ├── workflows/
│   │   └── ci-cd.yml                          # 🚀 CI/CD pipeline automation
│   └── .copilot-instructions.md               # 🧠 Copilot guidance
├── src/
│   ├── __init__.py
│   ├── agents/                                # 🤖 Agent implementations (stock, currency, report)
│   │   ├── __init__.py
│   │   ├── stock_agent.py
│   │   ├── currency_agent.py
│   │   └── report_agent.py
│   ├── utils/                                 # 🛠️ Shared utilities
│   │   ├── __init__.py
│   │   ├── config.py
│   │   └── api_clients.py
│   └── main.py                                # 🎯 Application entry point
├── tests/
│   ├── __init__.py
│   ├── conftest.py                            # 🔧 Shared pytest fixtures
│   ├── unit/                                  # 🧪 Unit tests (mocked dependencies)
│   │   ├── __init__.py
│   │   ├── test_stock_agent.py
│   │   ├── test_currency_agent.py
│   │   └── test_report_agent.py
│   └── integration/                           # 🔗 Integration tests (real/mocked external services)
│       ├── __init__.py
│       ├── test_azure_integration.py
│       └── test_end_to_end.py
├── evals/                                     # 📊 Agent performance evaluations (agents, RAG)
│   ├── __init__.py
│   ├── eval_stock_agent.py
│   ├── eval_currency_agent.py
│   └── eval_multi_agent.py
├── data/                                      # 📂 Grounding data
│   └── watchlist.json
├── docs/                                      # 📖 Human-facing documentation
│   ├── architecture.md
│   └── user-guide.md
├── IMPLEMENTATION_PLAN.md                     # ⭐ Milestone plan for Copilot + devs
├── README.md                                  # 📄 Project intro + usage
├── requirements.txt                           # 🐍 Python dependencies
├── .env                                       # 🔒 Local secrets (ignored)
└── .gitignore                                 # 🚫 Should ignore `.env`, `__pycache__`
```

### �🛠️ Code Patterns

#### Agent Structure
```python
class StockAgent:
    def __init__(self, api_key=None):
        self.api_key = api_key
    
    def extract_ticker(self, query: str) -> str:
        """Extract stock ticker from natural language query"""
        pass
    
    def fetch_stock_price(self, ticker: str) -> dict:
        """Fetch current stock price"""
        pass
    
    def process_query(self, query: str) -> str:
        """Main entry point for stock queries"""
        pass
```

#### Error Handling
- Always handle API failures gracefully
- Provide fallback responses for network issues
- Log errors for debugging across agents

#### Configuration Management
- Use environment variables for API keys
- Store configuration in `config.json` 
- Keep sensitive data out of source control

### 🔄 Multi-Agent Orchestration Patterns

#### Task Handoff
```python
# Stock Agent → Currency Agent handoff
stock_result = await stock_agent.get_price("TSLA")
currency_result = await currency_agent.convert_usd_to_sek(stock_result.price)
return f"{stock_result.ticker}: ${stock_result.price} USD = {currency_result} SEK"
```

#### Agent Registration
- Each agent should have clear capabilities and interfaces
- Use Azure AI Foundry agent registration patterns
- Implement proper async/await for agent communication

### 📊 Data Formats

#### Stock Data Response
```json
{
  "ticker": "TSLA",
  "company_name": "Tesla Inc",
  "price": 250.45,
  "currency": "USD",
  "timestamp": "2025-10-10T10:30:00Z",
  "change": "+2.15%"
}
```

#### Watchlist Format
```json
{
  "watchlist": [
    {
      "ticker": "TSLA",
      "company_name": "Tesla Inc",
      "target_price": 300.00,
      "notes": "EV leader"
    }
  ]
}
```

### 🔍 RAG Implementation Guidelines

#### Vector Embedding Strategy
- Use Azure AI Search with vector capabilities for watchlist embeddings
- Embed watchlist entries with company info, sector, notes, and financial metrics
- Create vector index for semantic search across stock data
- Implement hybrid search combining keyword and vector similarity

#### Retrieval Patterns
```python
from azure.search.documents import SearchClient
from azure.search.documents.models import VectorizedQuery

def get_relevant_watchlist_stocks(query: str, search_client: SearchClient, top_k: int = 3):
    """Retrieve relevant stocks from watchlist using vector similarity"""
    # Generate embedding for the query
    query_vector = generate_embedding(query)
    
    # Create vectorized query
    vector_query = VectorizedQuery(
        vector=query_vector,
        k_nearest_neighbors=top_k,
        fields="content_vector"
    )
    
    # Execute hybrid search (keyword + vector)
    results = search_client.search(
        search_text=query,
        vector_queries=[vector_query],
        select=["ticker", "company_name", "price", "notes", "sector"]
    )
    
    return list(results)
```

### 🚀 Deployment Guidelines

#### Local Development (Milestone 1)
- Use `python -m venv venv` for virtual environment
- Store API keys in `.env` file (add to .gitignore)
- Test with simple CLI interface

#### Azure Deployment (Milestone 2+)
- Package agents as Azure Functions or Container Apps
- Use Azure AI Foundry for agent orchestration
- Configure Azure Key Vault for secrets management
- Set up Application Insights for monitoring

### 🧪 Testing Strategy

#### Unit Tests (pytest)
- Use **pytest** as the primary testing framework
- Test ticker extraction logic with parametrized test cases
- Mock API responses using `pytest-mock` or `unittest.mock`
- Validate currency conversion accuracy with edge cases
- Structure tests in `tests/` directory with descriptive names
- Use pytest fixtures for common test data and setup

```python
# Example pytest structure
import pytest
from unittest.mock import Mock, patch
from src.agents.stock_agent import StockAgent

class TestStockAgent:
    @pytest.fixture
    def stock_agent(self):
        return StockAgent(api_key="test_key")
    
    @pytest.mark.parametrize("query,expected_ticker", [
        ("What's the price of Tesla?", "TSLA"),
        ("How much is Apple stock?", "AAPL"),
        ("NVIDIA price", "NVDA")
    ])
    def test_extract_ticker(self, stock_agent, query, expected_ticker):
        result = stock_agent.extract_ticker(query)
        assert result == expected_ticker
    
    @patch('src.agents.stock_agent.yfinance.Ticker')
    def test_fetch_stock_price_success(self, mock_ticker, stock_agent):
        # Mock API response
        mock_ticker.return_value.info = {'regularMarketPrice': 250.45}
        result = stock_agent.fetch_stock_price("TSLA")
        assert result['price'] == 250.45
```

### 📈 Monitoring & Observability

#### Logging
```python
import logging
logger = logging.getLogger(__name__)

def fetch_stock_price(self, ticker: str):
    logger.info(f"Fetching price for {ticker}")
    try:
        # API call
        logger.info(f"Successfully fetched {ticker}: ${price}")
    except Exception as e:
        logger.error(f"Failed to fetch {ticker}: {e}")
```

#### Metrics
- Track API response times
- Monitor agent handoff success rates
- Measure RAG retrieval relevance scores

### 🔒 Security Guidelines

#### API Key Management
- Never commit API keys to source control
- Use Azure Key Vault in production
- Rotate keys regularly

#### Input Validation
- Sanitize all user inputs
- Validate ticker symbols against known exchanges
- Prevent prompt injection attacks

### 📝 Documentation Standards

#### Code Comments
- Document complex ticker extraction logic
- Explain agent interaction patterns
- Note any API-specific quirks or limitations

#### README Updates
- **MANDATORY**: Update README.md at the end of each milestone before committing
- Keep installation instructions current
- Document environment setup for each milestone
- Include example queries and expected responses
- Update project structure to reflect new files and folders
- Ensure testing commands match current test organization
- Verify all configuration examples are accurate and current

## Milestone-Specific Guidance

### Milestone 1 - Local Stock Agent
- Focus on robust ticker extraction from natural language
- Implement clean error handling for API failures
- Create simple CLI interface for testing
- Set up pytest with basic unit tests for core functions
- Use pytest fixtures for test data and mock configurations
- **Update README.md** with current status, test structure, and usage instructions

### Milestone 2 - Azure Deployment
- Follow Azure AI Foundry best practices
- Set up proper CI/CD pipeline
- Configure monitoring and alerting
- **Update README.md** with deployment instructions and Azure-specific setup

### Milestone 3 - Multi-Agent Setup
- Design clear agent interfaces and contracts
- Implement proper async communication
- Add comprehensive logging for debugging
- **Update README.md** with multi-agent architecture and new usage patterns

### Milestone 4 - RAG Integration
- Choose appropriate embedding model for financial data
- Implement efficient similarity search
- Design good prompts that leverage retrieved context
- **Update README.md** with RAG setup instructions and watchlist configuration

### Milestone 5 - Reporting Agent
- Create flexible report templates
- Implement scheduling capabilities
- Add export functionality (PDF, email, etc.)
- **Update README.md** with reporting features and final architecture overview

## Code Quality Standards

### Type Hints
```python
from typing import Dict, List, Optional
def fetch_stock_data(ticker: str) -> Optional[Dict[str, any]]:
    pass
```

### Error Classes
```python
class StockNotFoundError(Exception):
    pass

class APIRateLimitError(Exception):
    pass
```

### Configuration Classes
```python
@dataclass
class AgentConfig:
    api_key: str
    rate_limit: int = 100
    timeout: int = 30
```

Remember: Always refer to `IMPLEMENTATION_PLAN.md` to understand the current milestone and next steps. Build incrementally and test thoroughly at each stage.